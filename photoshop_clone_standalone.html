<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini-Photoshop ‚Äî Standalone HTML</title>
<style>
  :root{--ui:#222;--muted:#666;--accent:#0b84ff}
  body{margin:0;font-family:Inter,Segoe UI,Roboto,system-ui,Arial;background:#111;color:#eee}
  .app{display:flex;height:100vh}
  .sidebar{width:92px;background:linear-gradient(#191919,#121212);padding:8px;box-sizing:border-box;display:flex;flex-direction:column;gap:8px}
  .tool{background:#1f1f1f;border-radius:8px;padding:8px;display:flex;align-items:center;justify-content:center;cursor:pointer}
  .tool.active{outline:2px solid var(--accent)}
  .topbar{height:56px;background:#0f0f0f;display:flex;align-items:center;padding:0 12px;gap:12px}
  .canvas-wrap{flex:1;display:flex;flex-direction:column}
  .stage{flex:1;background:#2b2b2b;display:flex;align-items:center;justify-content:center;overflow:auto}
  .board{position:relative;box-shadow:0 8px 30px rgba(0,0,0,.6);background:white}
  canvas.layer{position:absolute;left:0;top:0}
  .controls{display:flex;gap:8px;align-items:center}
  input[type=range]{width:120px}
  .rightpanel{width:260px;background:#121212;padding:10px;box-sizing:border-box;display:flex;flex-direction:column;gap:10px}
  label{font-size:12px;color:var(--muted)}
  button, .tool{user-select:none}
  .layers{background:#0e0e0e;padding:8px;border-radius:8px;max-height:280px;overflow:auto}
  .layer-row{display:flex;align-items:center;justify-content:space-between;padding:6px;border-radius:6px;background:#141414;margin-bottom:6px}
  .small{font-size:12px;color:var(--muted)}
  .hint{font-size:12px;color:#aaa}
</style>
</head>
<body>
<div class="app">
  <div class="sidebar">
    <div class="tool active" data-tool="brush" title="Brush">üñåÔ∏è</div>
    <div class="tool" data-tool="eraser" title="Eraser">ü©π</div>
    <div class="tool" data-tool="bucket" title="Fill">ü™£</div>
    <div class="tool" data-tool="rect" title="Rectangle">‚ñ≠</div>
    <div class="tool" data-tool="ellipse" title="Ellipse">‚óØ</div>
    <div class="tool" data-tool="select" title="Select">üî≤</div>
    <div class="tool" data-tool="move" title="Move/Pan">‚úã</div>
    <div class="tool" data-tool="text" title="Text">üî§</div>
  </div>

  <div style="flex:1;display:flex;flex-direction:column">
    <div class="topbar">
      <div class="controls">
        <button id="newBtn">New</button>
        <input id="fileIn" type="file" accept="image/*" />
        <button id="saveBtn">Export PNG</button>
        <button id="undoBtn">Undo</button>
        <button id="redoBtn">Redo</button>
      </div>
      <div style="flex:1"></div>
      <div class="controls">
        <label class="small">Zoom</label>
        <input id="zoom" type="range" min="10" max="300" value="100" />
      </div>
    </div>

    <div class="canvas-wrap">
      <div class="stage">
        <div id="board" class="board" style="width:800px;height:600px">
          <!-- layers get created by JS -->
        </div>
      </div>
    </div>
  </div>

  <div class="rightpanel">
    <div>
      <label class="small">Tool settings</label>
      <div style="display:flex;gap:8px;align-items:center;margin-top:6px">
        <input id="color" type="color" value="#000000" />
        <input id="size" type="range" min="1" max="200" value="8" />
        <span id="sizeVal" class="small">8</span>
      </div>
    </div>

    <div>
      <label class="small">Layers</label>
      <div class="layers" id="layers"></div>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="addLayer">Add</button>
        <button id="delLayer">Delete</button>
      </div>
    </div>

    <div>
      <label class="small">Quick actions</label>
      <div style="display:flex;flex-direction:column;gap:6px;margin-top:6px">
        <button id="flatten">Flatten & download</button>
        <button id="clear">Clear active</button>
        <button id="fit">Fit to window</button>
      </div>
    </div>

    <div>
      <label class="small">Hints</label>
      <div class="hint">Brush/Eraser: drag on canvas. Bucket: click. Select: drag to select. Text: click canvas to add text.</div>
    </div>
  </div>
</div>

<script>
/* Mini Photoshop clone in single HTML file.
   Features: multiple layers (canvas), brush, eraser, bucket fill (simple), shapes, select+crop, text, undo/redo, import/export, zoom.
   NOTE: This is a compact demo, not a production-grade editor. */

const board = document.getElementById('board');
let width = 800, height = 600;
let layers = []; // {canvas, ctx, name, visible}
let activeLayer = null;
let tool = 'brush';
let colorEl = document.getElementById('color');
let sizeEl = document.getElementById('size');
let sizeVal = document.getElementById('sizeVal');
let size = Number(sizeEl.value);
let color = colorEl.value;
let isDrawing=false, lastPos=null;
let history = [], historyIndex = -1;
let selection = null;
let zoomEl = document.getElementById('zoom');

function createLayer(name='Layer'){
  const c = document.createElement('canvas');
  c.width = width; c.height = height; c.className='layer';
  c.style.zIndex = layers.length;
  c.style.pointerEvents='auto';
  c.style.left='0'; c.style.top='0';
  c.style.opacity = 1;
  const ctx = c.getContext('2d');
  board.appendChild(c);
  const layer = {canvas:c, ctx, name, visible:true, opacity:1};
  layers.push(layer);
  activeLayer = layer;
  rebuildLayersUI();
  pushHistory();
  return layer;
}

function rebuildLayersUI(){
  const box = document.getElementById('layers');
  box.innerHTML='';
  for(let i=layers.length-1;i>=0;i--){
    const L=layers[i];
    const row = document.createElement('div'); row.className='layer-row';
    const left = document.createElement('div'); left.innerHTML=`<input type="checkbox" ${L.visible? 'checked':''} data-i="${i}" class="vis"> <b>${L.name}</b>`;
    const right = document.createElement('div');
    right.innerHTML=`<input data-i="${i}" type="range" min="0" max="100" value="${Math.round(L.opacity*100)}" title="opacity"/>`;
    row.appendChild(left); row.appendChild(right);
    box.appendChild(row);
  }
  // attach handlers
  box.querySelectorAll('.vis').forEach(cb=>{
    cb.onchange = e=>{ const i=Number(e.target.dataset.i); layers[i].visible = e.target.checked; layers[i].canvas.style.display = layers[i].visible? 'block':'none'; pushHistory(); }
  });
  box.querySelectorAll('input[type=range]').forEach(r=>{ r.oninput = e=>{ const i=Number(e.dataset.i); layers[i].opacity = Number(e.target.value)/100; layers[i].canvas.style.opacity = layers[i].opacity; }})
}

function setTool(t){ tool = t; document.querySelectorAll('.tool').forEach(el=>el.classList.toggle('active', el.dataset.tool===t)); }

// initialize
board.style.width = width+'px'; board.style.height = height+'px';
createLayer('Background'); // index 0
createLayer('Layer 1');

// wire UI
document.querySelectorAll('.tool').forEach(el=> el.addEventListener('click', ()=> setTool(el.dataset.tool)));
sizeEl.oninput = ()=>{ size = Number(sizeEl.value); sizeVal.textContent = size; }
colorEl.oninput = ()=>{ color = colorEl.value }

// add layer / delete
document.getElementById('addLayer').onclick = ()=> createLayer('Layer '+(layers.length));
document.getElementById('delLayer').onclick = ()=>{
  if(!activeLayer) return; const idx = layers.indexOf(activeLayer); if(idx>=0){ board.removeChild(activeLayer.canvas); layers.splice(idx,1); activeLayer = layers[layers.length-1] || null; rebuildLayersUI(); pushHistory(); }
}

// new, import, save
document.getElementById('newBtn').onclick = ()=>{
  width = prompt('Width in px',width) || width; height = prompt('Height in px',height) || height; width = Number(width); height = Number(height);
  // clear
  layers.forEach(l=> board.removeChild(l.canvas)); layers = []; activeLayer=null; board.style.width=width+'px'; board.style.height=height+'px'; createLayer('Background'); createLayer('Layer 1'); pushHistory();
}

const fileIn = document.getElementById('fileIn');
fileIn.onchange = e=>{ const f=e.target.files[0]; if(!f) return; const img=new Image(); img.onload=()=>{ // draw to background
    layers[0].canvas.width = width = img.width; layers[0].canvas.height = height = img.height; board.style.width=width+'px'; board.style.height=height+'px'; layers.forEach(l=>{ l.canvas.width = width; l.canvas.height = height; }); layers[0].ctx.clearRect(0,0,width,height); layers[0].ctx.drawImage(img,0,0); pushHistory(); }
  img.src = URL.createObjectURL(f);
}

function flatten(){
  const temp = document.createElement('canvas'); temp.width = width; temp.height = height; const tctx = temp.getContext('2d');
  layers.forEach(l=>{ if(!l.visible) return; tctx.globalAlpha = l.opacity; tctx.drawImage(l.canvas,0,0); });
  return temp;
}

document.getElementById('saveBtn').onclick = ()=>{
  const flat = flatten(); const a = document.createElement('a'); a.download='mini-ps.png'; a.href = flat.toDataURL('image/png'); a.click(); }

document.getElementById('flatten').onclick = ()=>{
  const flat = flatten(); // replace with single layer
  layers.forEach(l=> board.removeChild(l.canvas)); layers=[]; activeLayer=null;
  board.style.width=flat.width+'px'; board.style.height=flat.height+'px'; width=flat.width; height=flat.height;
  const c = document.createElement('canvas'); c.width=width; c.height=height; c.className='layer'; c.getContext('2d').drawImage(flat,0,0); board.appendChild(c); layers.push({canvas:c,ctx:c.getContext('2d'),name:'Flattened',visible:true,opacity:1}); activeLayer=layers[0]; rebuildLayersUI(); pushHistory();
  // auto-download
  const a = document.createElement('a'); a.download='flattened.png'; a.href = flat.toDataURL('image/png'); a.click();
}

// clear active
document.getElementById('clear').onclick = ()=>{ if(!activeLayer) return; activeLayer.ctx.clearRect(0,0,activeLayer.canvas.width,activeLayer.canvas.height); pushHistory(); }

// fit
document.getElementById('fit').onclick = ()=>{ const rect = document.querySelector('.stage').getBoundingClientRect(); const scale = Math.min(rect.width/width, rect.height/height, 1); zoomEl.value = Math.round(scale*100); applyZoom(); }

// undo/redo
function pushHistory(){
  // store flattened image dataURL for simplicity
  const flat = flatten(); const data = flat.toDataURL(); history = history.slice(0,historyIndex+1); history.push(data); historyIndex = history.length-1; updateUndoRedoBtns(); }
function updateUndoRedoBtns(){ document.getElementById('undoBtn').disabled = historyIndex<=0; document.getElementById('redoBtn').disabled = historyIndex>=history.length-1; }

document.getElementById('undoBtn').onclick = ()=>{ if(historyIndex<=0) return; historyIndex--; const img=new Image(); img.onload=()=>{ // replace all layers with single layer showing this image
    layers.forEach(l=> board.removeChild(l.canvas)); layers=[]; const c=document.createElement('canvas'); c.width=img.width; c.height=img.height; c.className='layer'; c.getContext('2d').drawImage(img,0,0); board.appendChild(c); layers.push({canvas:c,ctx:c.getContext('2d'),name:'Undo',visible:true,opacity:1}); activeLayer=layers[0]; board.style.width=img.width+'px'; board.style.height=img.height+'px'; width=img.width; height=img.height; rebuildLayersUI(); }
  img.src = history[historyIndex]; updateUndoRedoBtns(); }

document.getElementById('redoBtn').onclick = ()=>{ if(historyIndex>=history.length-1) return; historyIndex++; const img=new Image(); img.onload=()=>{ layers.forEach(l=> board.removeChild(l.canvas)); layers=[]; const c=document.createElement('canvas'); c.width=img.width; c.height=img.height; c.className='layer'; c.getContext('2d').drawImage(img,0,0); board.appendChild(c); layers.push({canvas:c,ctx:c.getContext('2d'),name:'Redo',visible:true,opacity:1}); activeLayer=layers[0]; board.style.width=img.width+'px'; board.style.height=img.height+'px'; width=img.width; height=img.height; rebuildLayersUI(); }
  img.src = history[historyIndex]; updateUndoRedoBtns(); }

// drawing handlers
board.addEventListener('pointerdown', onDown);
board.addEventListener('pointermove', onMove);
document.addEventListener('pointerup', onUp);

function getBoardPos(e){ const rect = board.getBoundingClientRect(); const x = (e.clientX - rect.left) * (width/rect.width); const y = (e.clientY - rect.top) * (height/rect.height); return {x,y}; }

function onDown(e){ if(!activeLayer) return; const p = getBoardPos(e); if(tool==='brush' || tool==='eraser'){
    isDrawing=true; lastPos = p; drawStroke(p, p, true);
  } else if(tool==='bucket'){
    bucketFill(activeLayer, Math.round(p.x), Math.round(p.y), hexToRgba(color)); pushHistory();
  } else if(tool==='rect' || tool==='ellipse'){
    isDrawing=true; selection = {x:p.x,y:p.y,w:0,h:0,type:tool};
  } else if(tool==='select'){
    isDrawing=true; selection = {x:p.x,y:p.y,w:0,h:0,type:'select'};
  } else if(tool==='text'){
    const txt = prompt('Enter text'); if(txt){ activeLayer.ctx.fillStyle = color; activeLayer.ctx.font = `${size*4}px sans-serif`; activeLayer.ctx.fillText(txt, p.x, p.y); pushHistory(); }
  } else if(tool==='move'){
    // pan not implemented; could implement later
  }
}
function onMove(e){ if(!isDrawing) return; const p = getBoardPos(e); if(tool==='brush' || tool==='eraser'){
    drawStroke(lastPos, p); lastPos = p;
  } else if(tool==='rect' || tool==='ellipse' || tool==='select'){
    selection.w = p.x - selection.x; selection.h = p.y - selection.y; redrawOverlay(); }
}
function onUp(e){ if(!isDrawing) return; isDrawing=false; if(tool==='rect' || tool==='ellipse'){ renderShape(selection); selection=null; removeOverlay(); pushHistory(); } else if(tool==='select'){ // crop to selection
    const s = normalizeSelection(selection); if(!s) { selection=null; removeOverlay(); return; }
    // create new canvas from selection and replace active
    const data = activeLayer.ctx.getImageData(s.x,s.y,s.w,s.h);
    activeLayer.canvas.width = s.w; activeLayer.canvas.height = s.h; activeLayer.ctx.clearRect(0,0,s.w,s.h); activeLayer.ctx.putImageData(data,0,0); board.style.width = s.w+'px'; board.style.height = s.h+'px'; width=s.w;height=s.h; layers.forEach(l=>{ if(l!==activeLayer){ board.removeChild(l.canvas); } }); layers = [activeLayer]; activeLayer.canvas.style.zIndex=0; selection=null; removeOverlay(); rebuildLayersUI(); pushHistory(); }
}

function drawStroke(from,to,init=false){ const ctx = activeLayer.ctx; ctx.lineCap='round'; ctx.lineJoin='round'; ctx.lineWidth = size; ctx.strokeStyle = (tool==='eraser')? 'rgba(0,0,0,1)': color; if(tool==='eraser'){ ctx.globalCompositeOperation='destination-out'; } else { ctx.globalCompositeOperation='source-over'; }
  ctx.beginPath(); ctx.moveTo(from.x, from.y); ctx.lineTo(to.x, to.y); ctx.stroke(); ctx.closePath(); if(init) ctx.beginPath(); }

// simple rectangle/ellipse rendering
function renderShape(sel){ const ctx = activeLayer.ctx; ctx.save(); ctx.fillStyle = color; ctx.strokeStyle = color; ctx.lineWidth = size/4; const n = normalizeSelection(sel); if(!n) return; if(sel.type==='rect'){ ctx.fillRect(n.x,n.y,n.w,n.h); } else if(sel.type==='ellipse'){ ctx.beginPath(); ctx.ellipse(n.x + n.w/2, n.y + n.h/2, Math.abs(n.w/2), Math.abs(n.h/2), 0, 0, Math.PI*2); ctx.fill(); }
  ctx.restore(); }

function normalizeSelection(s){ if(!s) return null; let x=s.x,y=s.y,w=s.w,h=s.h; if(Math.abs(w)<2 || Math.abs(h)<2) return null; if(w<0){ x+=w; w=Math.abs(w);} if(h<0){ y+=h; h=Math.abs(h);} x=Math.max(0,Math.round(x)); y=Math.max(0,Math.round(y)); w=Math.min(width-x,Math.round(w)); h=Math.min(height-y,Math.round(h)); return {x,y,w,h}; }

// overlay for selection preview
let overlay = null;
function redrawOverlay(){ if(!selection) return; if(!overlay){ overlay = document.createElement('div'); overlay.style.position='absolute'; overlay.style.border='1px dashed #fff'; overlay.style.pointerEvents='none'; board.appendChild(overlay); }
  const s = normalizeSelection(selection); if(!s) return; overlay.style.left = s.x+'px'; overlay.style.top = s.y+'px'; overlay.style.width = s.w+'px'; overlay.style.height = s.h+'px'; }
function removeOverlay(){ if(overlay){ board.removeChild(overlay); overlay=null; }}

// Bucket fill (naive pixel flood-fill)
function bucketFill(layer, startX, startY, fillColor){ const ctx = layer.ctx; const img = ctx.getImageData(0,0,layer.canvas.width,layer.canvas.height); const w=img.width,h=img.height; const data=img.data; const idx = (y=> (x)=> (y*w + x)*4);
  function getPixel(x,y){ const i = (y*w + x)*4; return [data[i],data[i+1],data[i+2],data[i+3]] }
  function setPixel(x,y,col){ const i=(y*w+x)*4; data[i]=col[0]; data[i+1]=col[1]; data[i+2]=col[2]; data[i+3]=col[3]; }
  if(startX<0||startY<0||startX>=w||startY>=h) return;
  const target = getPixel(startX,startY); const fill = fillColor; if(pixelEq(target,fill)) return;
  const stack = [[startX,startY]]; while(stack.length){ const [x,y] = stack.pop(); const p = getPixel(x,y); if(!pixelEq(p,target)) continue; setPixel(x,y,fill);
    if(x>0) stack.push([x-1,y]); if(x<w-1) stack.push([x+1,y]); if(y>0) stack.push([x,y-1]); if(y<h-1) stack.push([x,y+1]); }
  ctx.putImageData(img,0,0);
}
function pixelEq(a,b){ return a[0]===b[0] && a[1]===b[1] && a[2]===b[2] && a[3]===b[3]; }
function hexToRgba(h){ const c = h.replace('#',''); const r=parseInt(c.substring(0,2),16); const g=parseInt(c.substring(2,4),16); const b=parseInt(c.substring(4,6),16); return [r,g,b,255]; }

// zoom handling
function applyZoom(){ const z = Number(zoomEl.value)/100; board.style.transform = `scale(${z})`; board.style.transformOrigin='0 0'; }
zoomEl.oninput = applyZoom; applyZoom();

// basic keyboard shortcuts
window.addEventListener('keydown', e=>{
  if((e.ctrlKey||e.metaKey) && e.key==='z'){ document.getElementById('undoBtn').click(); }
  if((e.ctrlKey||e.metaKey) && e.key==='y'){ document.getElementById('redoBtn').click(); }
  if(e.key==='b') setTool('brush'); if(e.key==='e') setTool('eraser'); if(e.key==='g') setTool('bucket'); if(e.key==='v') setTool('move');
});

// set initial activeLayer clickable to set active
board.addEventListener('pointerdown', function setActiveOnClick(e){ const target = e.target; if(target.tagName==='CANVAS'){ const l = layers.find(L=>L.canvas===target); if(l){ activeLayer = l; } } }, {capture:true});

// initial history snapshot
pushHistory();

</script>
</body>
</html>
